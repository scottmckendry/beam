// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: migration.sql

package db

import (
	"context"
)

const applyMigration = `-- name: ApplyMigration :exec
INSERT INTO migrations (name, applied)
VALUES (?, datetime('now'))
`

func (q *Queries) ApplyMigration(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, applyMigration, name)
	return err
}

const createMigrationsTable = `-- name: CreateMigrationsTable :exec
CREATE TABLE IF NOT EXISTS migrations (
    id UUID PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    name TEXT NOT NULL UNIQUE,
    applied DATETIME NOT NULL DEFAULT (datetime('now'))
)
`

func (q *Queries) CreateMigrationsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createMigrationsTable)
	return err
}

const getMigration = `-- name: GetMigration :one
SELECT id, name, applied FROM migrations
WHERE name = ? LIMIT 1
`

func (q *Queries) GetMigration(ctx context.Context, name string) (Migration, error) {
	row := q.db.QueryRowContext(ctx, getMigration, name)
	var i Migration
	err := row.Scan(&i.ID, &i.Name, &i.Applied)
	return i, err
}

const listMigrations = `-- name: ListMigrations :many
SELECT id, name, applied FROM migrations
`

func (q *Queries) ListMigrations(ctx context.Context) ([]Migration, error) {
	rows, err := q.db.QueryContext(ctx, listMigrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Migration
	for rows.Next() {
		var i Migration
		if err := rows.Scan(&i.ID, &i.Name, &i.Applied); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
