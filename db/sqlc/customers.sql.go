// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customers.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (name, logo, status, email, phone, address, website, notes)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, logo, status, email, phone, address, website, notes, created_at, updated_at
`

type CreateCustomerParams struct {
	Name    string
	Logo    sql.NullString
	Status  string
	Email   sql.NullString
	Phone   sql.NullString
	Address sql.NullString
	Website sql.NullString
	Notes   sql.NullString
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.Name,
		arg.Logo,
		arg.Status,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.Website,
		arg.Notes,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.Status,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.Website,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomer = `-- name: GetCustomer :one
SELECT
    c.id, c.name, c.logo, c.status, c.email, c.phone, c.address, c.website, c.notes, c.created_at, c.updated_at,
    (SELECT COUNT(*) FROM contacts WHERE customer_id = c.id) AS contact_count,
    3 AS subscription_count, -- TODO: Replace with actual count from subscriptions table
    8 AS project_count -- TODO: Replace with actual count from projects table
FROM customers c
WHERE c.id = ?
`

type GetCustomerRow struct {
	ID                uuid.UUID
	Name              string
	Logo              sql.NullString
	Status            string
	Email             sql.NullString
	Phone             sql.NullString
	Address           sql.NullString
	Website           sql.NullString
	Notes             sql.NullString
	CreatedAt         sql.NullTime
	UpdatedAt         sql.NullTime
	ContactCount      int64
	SubscriptionCount int64
	ProjectCount      int64
}

func (q *Queries) GetCustomer(ctx context.Context, id uuid.UUID) (GetCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i GetCustomerRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.Status,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.Website,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactCount,
		&i.SubscriptionCount,
		&i.ProjectCount,
	)
	return i, err
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, name, logo, status, email, phone, address, website, notes, created_at, updated_at FROM customers ORDER BY created_at DESC
`

func (q *Queries) ListCustomers(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Logo,
			&i.Status,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.Website,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
