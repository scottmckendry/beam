// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customers.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (name, logo, status, email, phone, address, website, notes)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, logo, status, email, phone, address, website, notes, created_at, updated_at, deleted_at
`

type CreateCustomerParams struct {
	Name    string
	Logo    sql.NullString
	Status  string
	Email   sql.NullString
	Phone   sql.NullString
	Address sql.NullString
	Website sql.NullString
	Notes   sql.NullString
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.Name,
		arg.Logo,
		arg.Status,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.Website,
		arg.Notes,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.Status,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.Website,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :one
UPDATE customers
SET deleted_at = datetime('now')
WHERE id = ?
RETURNING id, name, logo, status, email, phone, address, website, notes, created_at, updated_at, deleted_at
`

func (q *Queries) DeleteCustomer(ctx context.Context, id uuid.UUID) (Customer, error) {
	row := q.db.QueryRowContext(ctx, deleteCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.Status,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.Website,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCustomer = `-- name: GetCustomer :one
SELECT
    c.id, c.name, c.logo, c.status, c.email, c.phone, c.address, c.website, c.notes, c.created_at, c.updated_at, c.deleted_at,
    (SELECT COUNT(*) FROM contacts WHERE customer_id = c.id AND deleted_at IS NULL) AS contact_count,
    -- TODO: Replace these with actual counts from the respective tables
    3 AS subscription_count,
    8 AS project_count,
    238 AS subscription_revenue,
    267 AS monthly_revenue,
    15 AS revenue_change
FROM customers c
WHERE c.id = ? AND c.deleted_at IS NULL
`

type GetCustomerRow struct {
	ID                  uuid.UUID
	Name                string
	Logo                sql.NullString
	Status              string
	Email               sql.NullString
	Phone               sql.NullString
	Address             sql.NullString
	Website             sql.NullString
	Notes               sql.NullString
	CreatedAt           sql.NullTime
	UpdatedAt           sql.NullTime
	DeletedAt           sql.NullTime
	ContactCount        int64
	SubscriptionCount   int64
	ProjectCount        int64
	SubscriptionRevenue int64
	MonthlyRevenue      int64
	RevenueChange       int64
}

func (q *Queries) GetCustomer(ctx context.Context, id uuid.UUID) (GetCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i GetCustomerRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.Status,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.Website,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ContactCount,
		&i.SubscriptionCount,
		&i.ProjectCount,
		&i.SubscriptionRevenue,
		&i.MonthlyRevenue,
		&i.RevenueChange,
	)
	return i, err
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, name, logo, status, email, phone, address, website, notes, created_at, updated_at, deleted_at FROM customers WHERE deleted_at IS NULL ORDER BY created_at DESC
`

func (q *Queries) ListCustomers(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Logo,
			&i.Status,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.Website,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers
SET name = ?, logo = ?, status = ?, email = ?, phone = ?, address = ?, website = ?, notes = ?
WHERE id = ?
RETURNING id, name, logo, status, email, phone, address, website, notes, created_at, updated_at, deleted_at
`

type UpdateCustomerParams struct {
	Name    string
	Logo    sql.NullString
	Status  string
	Email   sql.NullString
	Phone   sql.NullString
	Address sql.NullString
	Website sql.NullString
	Notes   sql.NullString
	ID      uuid.UUID
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, updateCustomer,
		arg.Name,
		arg.Logo,
		arg.Status,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.Website,
		arg.Notes,
		arg.ID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.Status,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.Website,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateCustomerLogo = `-- name: UpdateCustomerLogo :exec
UPDATE customers
SET logo = ?
WHERE id = ?
`

type UpdateCustomerLogoParams struct {
	Logo sql.NullString
	ID   uuid.UUID
}

func (q *Queries) UpdateCustomerLogo(ctx context.Context, arg UpdateCustomerLogoParams) error {
	_, err := q.db.ExecContext(ctx, updateCustomerLogo, arg.Logo, arg.ID)
	return err
}
